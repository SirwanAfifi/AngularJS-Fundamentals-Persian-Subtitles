1
00:00:00,310 --> 00:00:04,000
‫خب، اجازه دهید ببینیم سرویس http چگونه کار میکند.

2
00:00:04,000 --> 00:00:09,000
‫اگر به یاد داشته باشید یک کنترلر داریم که سرویس eventData را
‫فراخوانی میکرد و سرویس در eventData نیز

3
00:00:09,000 --> 00:00:12,000
‫به صورت inline یه شیء را تعریف کردیم.

4
00:00:12,000 --> 00:00:18,000
‫درباره اینکه می‌خواهیم در واقع این شیء را از طریق ای جکس بازیابی کنیم
‫صحبت کردیم، خب اجازه دهید اینکار را توسط سرویس http انجام دهیم

5
00:00:18,000 --> 00:00:27,000
‫بنابراین، سرویس http را داخل سرویس eventData تزریق می‌کنیم.

6
00:00:27,000 --> 00:00:36,000
‫اجازه دهید نام این را به getEvent تغییر دهم و این قرار است یک تابع باشد.

7
00:00:36,000 --> 00:00:45,000
‫اجازه دهید این دادها را بردارم. خب، یک سرویس eventData داریم که
‫دارای یک تابع با نام getEvent می‌باشد

8
00:00:45,000 --> 00:00:52,000
‫و می‌خواهیم یک فراخوانی به صورت http را به عنوان قستمی از این تابع داشته باشیم.
‫بنابراین، سرویس http را صدا می‌زنیم،

9
00:00:52,000 --> 00:01:04,000
‫متد Get را برای آن مشخص می‌کنیم، و آدرس منبع را وارد می‌کنیم.

10
00:01:04,000 --> 00:01:11,000
‫که یک URL معتبر است. یک فایل در این مسیر است که فرمت آن

11
00:01:11,000 --> 00:01:17,000
‫JSON است و وقتی از طریق مرورگرم آن را باز میکنم اطلاعات را برایم نشان میدهد.

12
00:01:17,000 --> 00:01:29,000
‫سپس باید متد success را نیز تعیین کنیم، بنابراین چه اتفاقی رخ می‌هد وقتی درخواست
‫ای جکس با موفقیت انجام میشود؟

13
00:01:29,000 --> 00:01:44,000
‫در صورت موفقیت دادها را بر میگرداند همچنین لازم است callback
‫مربوط به error را نیز تعیین کنیم

14
00:01:44,000 --> 00:01:53,000
‫خب، در صورت موفقیت می‌خواهم چه کاری انجام دهد؟
‫خب، چونکه فراخوانی http به صورت
‫غیرهمزمان می‌باشد نمی‌تونم فقط آن را برگردانیم.

15
00:01:53,000 --> 00:02:01,000
‫بنابراین، کاری که می‌خوایم انجام بدیم وقتی تابع getEvent را صدا میزنیم،
‫یک callback را به آن پاس می‌دهیم

16
00:02:01,000 --> 00:02:04,000
‫که میتونیم در صورت موفقیت اون رو صدا بزنیم.

17
00:02:04,000 --> 00:02:09,000
‫اجازه دهید داده ای که از درخواست ای جکس دریافت می‌کنیم را به اون تابع پاس بدهیم.

18
00:02:09,000 --> 00:02:15,000
‫برای error هم یکسری داده را log می‌کنیم اما به جای استفاده از console. log

19
00:02:15,000 --> 00:02:19,000
‫اجازه دهید نحوه کار با سرویس log را به شما نشان دهم.

20
00:02:19,000 --> 00:02:26,000
‫log در اصل برای اهداف عیب یابی می‌باشد.

21
00:02:26,000 --> 00:02:35,000
‫بنابراین، در این حالت یک هشدار را تعیین میکنیم و data و بقیه پارامترها
‫را به آن پاس میدهیم.

22
00:02:35,000 --> 00:02:44,000
‫اکنون اجازه دهید به کنترلرمون برگردیم و متد getEvent
‫را صدا بزنیم و همانطور که به یاد دارید

23
00:02:44,000 --> 00:02:54,000
‫یک callback برای حالت success دارد.
‫از یک تابع inline استفاده میکنم و کاری که انجام
‫می‌دهیم مقدار event را مقداردهی می‌کنیم.

24
00:03:01,000 --> 00:03:09,000
‫اکنون اگر صفحه را ریفرش کنیم همانطور که مشاهده میکنید داده‌ها را دریافت می‌کنیم

25
00:03:09,000 --> 00:03:15,000
‫وقتی صفحه را ریفرش می‌کنیم داده‌ها توسط ای جکس فراخوانی میشوند.

26
00:03:15,000 --> 00:03:24,000
‫و اگر به کنسول مراجعه کنیم هیچ پیام لاگ شده ایی را نمی‌بینیم، اما اگر
‫در داخل کد یک آدرس نامعتبر را وارد کنیم

27
00:03:24,000 --> 00:03:35,000
‫و صفحه را ریفرش کنیم پیام‌ها در کنسول لاگ شده اند.

28
00:03:35,000 --> 00:03:39,000
‫این تابع که لاگ شده است هدرها می‌باشند.

29
00:03:39,000 --> 00:03:44,000
‫در واقع به عنوان یک تابع نیز می‌تواند پاس داده شود و تمام
‫هدرها را به صورت هش شده باز میگرداند.

30
00:03:44,000 --> 00:03:52,000
‫بنابراین اگر صفحه را ریفرش کنم همانطور که مشاهده می‌کنید
‫یک شیء خالی می‌باشد. و هدری برگردانده نمی‌شود.

31
00:03:52,000 --> 00:04:08,000
‫اجازه دهید آدرس رو اصلاح کنم

32
00:04:08,000 --> 00:04:15,000
‫خب کنسول رو پاک می‌کنم و دوباره صفحه رو ریفرش میکنم.

33
00:04:15,000 --> 00:04:23,000
‫دقت کنید که در لاگ‌ها یک شیء داریم بنابراین اینها هدرهایی هستند که
‫برگردانده شده اند

34
00:04:23,000 --> 00:04:31,000
‫و کد وضعیت 200 را داریم. داده ایی که از این شیء event دریافت کرده ایم
‫همان چیزی است که انتظار داشتیم از فایل JSON دریافت شوند.

35
00:04:31,000 --> 00:04:42,000
‫این‌ها هدرهایمان هستند و همچنین این شیء configی است
‫که برگردانده شده است.

36
00:04:42,000 --> 00:04:46,000
‫و درواقع پیکربندی ای است که برای درخواست ای جکس لارم است.

37
00:04:46,000 --> 00:04:49,000
‫که در اینجا هم متدGET و هم URLمان را داریم.

38
00:04:49,000 --> 00:04:57,000
‫خب، این کار سرویس http است. خیلی ساده و قابل فهم می‌باشد.

39
00:04:57,000 --> 00:05:04,000
‫اما صدا زدن callback در اینجا روش ایده آلی نیست.

40
00:05:04,000 --> 00:05:11,000
‫بنابراین، اجازه دهید نگاهی بر عملکرد کتابخانه q داشته باشیم
‫که برای حل این مشکل به کمک ما خواهد آمد.

41
00:05:11,000 --> 00:05:26,000
‫اجازه دهید به سرویس eventData برگردیم و در اینجا یک promise ایجاد کنیم.

42
00:05:26,000 --> 00:05:36,000
‫خب، q. defer را صدا میزنیم و باید q را به عنوان پارامتر مشخص کنیم.
‫اجازه دهید این logging را برداریم.

43
00:05:36,000 --> 00:05:52,000
‫سپس در اینجا می‌توانیم deferred. resolve را فراخوانی کنیم سپس
‫data را به آن پاس میدهم، همچنین در قسمت error نیز

44
00:05:52,000 --> 00:06:02,000
‫deferred. reject را فراخوانی میکنم و status را به آن پاس خواهم داد.

45
00:06:02,000 --> 00:06:12,000
‫سپس در نهایت یک promise را از شیء deferred بر میگردانیم.

46
00:06:12,000 --> 00:06:19,000
‫خب اگر با کتابخانه‌های promise آشنا نیستید، به این صورت است که
‫روشی را جهت کار با درخواست‌های asynchronous دراختیارتان قرار میدهند.

47
00:06:19,000 --> 00:06:27,000
‫و کاری که انجام میدن به صورت همزمان و بلافاصله
‫یک promise را برای شما برمیگردانند
‫و این promise یک شیء است که معمولاً

48
00:06:27,000 --> 00:06:34,000
‫دارای یک متد مانند then است. و وقتیکه این then را فراخوانی کنید
‫یک متد را به آن می‌دهید و وقتیکه promise کار خود را انجام داد

49
00:06:34,000 --> 00:06:44,000
‫آن متد را برای شما فراخوانی میکند. در نتیجه این امکان را به شما میدهد
‫تا از پاس دادن callback‌ها خوداری کنید.

50
00:06:44,000 --> 00:06:50,000
‫بسیار خب، اکنون داخل کنترلر این را به حالت قبلی تغییر میدهیم

51
00:06:50,000 --> 00:07:02,000
‫یعنی مقداری که توسط getEvent برگشت داده می‌شود. و اگر به یاد داشته باشید
‫چیزی که توسط سرویس مان برگشت داده می‌شود یک promise است.

52
00:07:02,000 --> 00:07:09,000
‫بنابراین دیگر success callback را لازم نداریم.

53
00:07:09,000 --> 00:07:15,000
‫خب اجازه دهید برنامه را اجرا کنیم و ببینیم چه اتفاقی می‌افتد.

54
00:07:15,000 --> 00:07:21,000
‫خب داده‌ها نمایش داده شده اند، حتی اگرچه با promise اینکار را انجام دادیم.

55
00:07:21,000 --> 00:07:35,000
‫خب جهت توضیح بیشتر، اجازه دهید در اینجا این خروجی event را توسط
‫console چاپ کنیم.

56
00:07:35,000 --> 00:07:44,000
‫توجه داشته باشید که این یک شیء event نیست، بلکه یک نوع خاص از promise
‫است که انگولار می‌داند چطور با آن کار کند

57
00:07:44,000 --> 00:07:49,000
‫بنابراین انگولار این promise را گرفته و تازمانیکه داده‌ها دریافت شوند منتظر می‌ماند

58
00:07:49,000 --> 00:07:57,000
‫سپس آنها را بایند میکند.

59
00:07:57,000 --> 00:08:00,000
‫و دیگر نیازی به تعریف callbackها نیست.

60
00:08:00,000 --> 00:08:07,000
‫اکنون، یک نکته رو به یاد داشته باشید، اگر قرار بود یک متد رو مثلاً در اینجا داخل
‫کنترلرتان به این صورت

61
00:08:07,000 --> 00:08:17,000
‫scope. event. name تعریف کنید و یا چیزی شبیه به آن، نتیجه ایی نخواهید گرفت
‫زیرا event در اینجا یک promise است.

62
00:08:17,000 --> 00:08:26,000
‫و این یک دلیل good practice بودن آن است، یک best proctice
‫داخل کنترلتان

63
00:08:26,000 --> 00:08:34,000
‫که پراپرتی‌ها و مدل‌های scope را فراخوانی میکند.
‫اگر در داخل view

64
00:08:34,000 --> 00:08:40,000
‫جهت پاس دادن برای شما در دسترس باشند، به جای
‫پاس دادن promise از view،

65
00:08:40,000 --> 00:08:44,000
‫در واقع به یک شیء آن را پاس میدهد.

66
00:08:44,000 --> 00:08:49,000
‫بهتر است به صورت عملی آن را ببنید،

67
00:08:49,000 --> 00:08:54,000
‫خب اجازه دهید از این متد استفاده کنیم.

68
00:08:54,000 --> 00:09:08,000
‫یک event را به عنوان پارامتر تعیین میکنیم و در خروجی
‫با استفاده از دستور console. log خود event و همچنین scope. event
‫را چاپ میکنیم.

69
00:09:08,000 --> 00:09:21,000
‫خب اکنون، در HTML شیء event را پاس میدهیم.
‫خب، کاری که قرار است انجام شود: برگرداندن

70
00:09:21,000 --> 00:09:28,000
‫promise از سرویس میباشد. scope. evet در واقع قرار است به view مان بایند شود

71
00:09:28,000 --> 00:09:37,000
‫اما نکته جالب این است که وقتی event را به کنترلرمون پاس میدهیم

72
00:09:37,000 --> 00:09:49,000
‫چه اتفاقی خواهد افتاد؟ خب، اگر صفحه را ریفرش کنم و اینجا کلیک کنم،

73
00:09:49,000 --> 00:09:57,000
‫توجه داشته باشید که وقتی رو آن کلیک میکنم event و scope. event
‫در خروجی لاگ می‌شوند.

74
00:09:57,000 --> 00:10:04,000
‫به تفاوت بین آنها توجه کنید. event تنها یک شیء event است،
‫اما scope. event هنوز یک promise می‌باشد.

75
00:10:04,000 --> 00:10:11,000
‫همچنین یک تفاوت دیگر در دسترسی به promise تان داخل کنترلرتان است

76
00:10:11,000 --> 00:10:15,000
‫و دسترسی به آنها بعد از اینکه به view پاس داده شدند.

77
00:10:15,000 --> 00:10:23,000
‫بنابراین، این هم دلیلی برای best practice بودن آن است
‫یعنی پاس دادن داده‌ها از view به جای اینکه

78
00:10:23,000 --> 00:10:30,000
‫از طریق scope به اشیاء دسترسی داشت.

79
00:10:30,000 --> 00:10:38,000
‫اکنون، اگر وقتی promise کار خود را به پایان رساند 
نیاز به دسترسی به event از کنترلرتان داشته باشید چطور؟

80
00:10:38,000 --> 00:10:44,000
‫خب همانند دیگر promise‌ها می‌توانید از این promise استفاده کنید

81
00:10:44,000 --> 00:10:53,000
‫یعنی scope. event که یک promise است را به این صورت استفاده کنید

82
00:10:53,000 --> 00:11:07,000
‫میتونیم از then استفاده کنیم.

83
00:11:07,000 --> 00:11:24,000
‫همچنین می‌تونیم status را نیز برگردانیم. خب اکنون می‌توانیم
‫به شیء event دسترسی داشته باشیم

84
00:11:24,000 --> 00:11:36,000
‫خب اجازه دهید event را در اینجا log کنیم و status را نیز در اینجا.

85
00:11:36,000 --> 00:11:49,000
‫اکنون، اجازه دهید خروجی کنسول را پاک کنم و صفحه را ریفرش کنم
‫دقت کنید که event در اینجا چاپ شده است.

86
00:11:49,000 --> 00:11:58,000
‫بنابراین، این promiseها همانند دیگر promise‌ها عمل میکنند،
‫اما انگولار نحوه بایند کردن آنها را میداند که خیلی جالب می‌باشد.

87
00:11:58,000 --> 00:12:04,000
‫خب، این نحوه استفاده از سرویس‌های http و q است.
‫در قسمت بعدی نحوه استفاده از شیء resource

88
00:12:04,000 --> 00:12:09,000
‫به جای شیء http جهت درخواست‌های RESTful را بررسی خواهیم کرد.

